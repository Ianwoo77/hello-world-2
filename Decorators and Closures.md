## Decorators and Closures

Function decorators let us mark functions in the source code to enhance their behavior in some way. The most obscure resreved keyword in py is `nonlocal`-- 3.0 -- cna have  a profitable life -- Aside from their application in decorators, closures are also essential for any type of programming using callbacks, and for coding in a functional style when it makes sense.

Caching decorator `functools.cache`new in 3.9 -- is simpler than the traditional `functools.lru_cache`.

### Decorators 101

Just a callable that take another function as an argument -- A decorator may perform some processing with the decorated function, and returns it or replaces it with another function or callback object. Just:

```py
@decorate
def target():
    ...
target = decoate(target)
```

The end result is the same -- at the end of eitherof these the `target`name is bound to whatever function is returned by `decorate(target)`-- whcih may be the function initially named `target`, or may be a different function.

```py
def deco(func):
    def inner():
        print('running inner()')
    return inner

@deco
def target():
    print('running target()')
    
target()
target
```

1. `deco`just returns its `inner`function object
2. `target`is decorated by `deco`
3. Invoking the decorated `target`actually runs `inner`.
4. Inspection reveals that `target`is now a reference to `inner`.

A key feature of decorators is that they run right after the decorated function is defined. This is usually at *import* time :

```py
registry=[]
def register(func):
    print(f'running register({func})')
    registry.append(func)
    return func

@register
def f1():
    print('running f1()')
    
@register
def f2():
    print('running f2()')
    
print(registry)
f1(); f2(); 
```

1. `registry`will hold references to functions decorated by `@register`
2. `register`takes a function as an argument
3. `return func`-- we must return a function, return the same received as argument
4. `f1`and `f2`are just decorated by `@register`

Just note that `register`runs (twice) before any other function in the module.

### Registration Decorators

Considering in the real code -- is usual in two ways: 

- The decorator function is defined in the same module and are decorated functions. A real decorator is usually defined in one module and applied to functions in other modules.
- The `register`decorator returns the same function passes as an argument -- in practie, most decorators define an inner function and return it.

### Variable Scope Rules

```py
def f1(a):
    print(a)
    print(b)
f1(3) # error, global 'b' is not defined
```

The error we got is not surprising -- if : b=6, f1(3) will run. But:

```py
b=9
def f2(a):
    print(a, b)
    b=9
f2(3) # error, local b reference before assignment
```

Note that -- which proves that `print(a)`statement was just executed -- In fact, When Py compiles the body of the function, just decides that `b`is a local variable cuz it is assigned within the function and the generated bytecode reflects this decistion and will try to fetch `b`from the local scope.

If -- want the interpreter to treat b as a global variable and still assign a a new value to it within the funciton, use `global`declaration -- 

```py
b=6
def f3(a):
    global b
    print(a)
    print(b)
    b=9
f3(3)
```

In this, can see two scopes in action -- 

Module global scope -- Made of names assigns to values outside any class or function block -- There is also another called `nonlocal`and is fundamental for closures.

### Closures

Are sometimes confused -- Actually is a function -- With an extended scope that encompasses variables referenced in the body of `f`that are not global variables or local variable of `f`. Such variables must come from the local scope of an outer function that encompasses f.

```py
class Averager:
    def __init__(self):
        self.series = []

    def __call__(self, new_value):
        self.series.append(new_value)
        total = sum(self.series)
        return total / len(self.series)
```

Can use the high-order function `make-averager`like:

```py
def make_averager():
    series =[]
    def averager(new_value):
        series.append(new_value)
        total= sum(series)
        return total/len(series)
    return averager

avg= make_averager()
avg(10)
avg(11)
avg(12)
```

Just note that the similarities of the examples call `Averager()`or `make_averager()`to get a callable object `avg`that will update the historical series and calculate the current mean. It's obvious where the `avg`of the `Averager`class keep the history -- `self.series`

Note that the `series`is just a local variable `make_averager`cuz the assignment `series=[]`happens in the body of that func -- but when `avb(10)`is called, `make_averager`has already returned, and its local scope is long gong.

Within `averager`, `series`is **free variable** -- this is a technical term meaning a variable that is not bound in the local scope.

```py
avg.__code__.co_varnames
avg.__code__.co_freevars
```

The values for `series`is kept in the `__closure__`attribute of the returned function `avg`-- each item in the `avg.__closure__` corresponds to a name in `avg.__code__`.co_freevars -- these items are cells, and they have an attribute called `cell_centents`.

### The nonlocal Declaration

Note that the previous implementation of `make_averager`was not efficient -- we stored all the values in the historical series and computed their `sum`every time `averager`was called -- a better implementation would store the total and the numbe rof items so far, and compute the mean from two numbers just like:

```py
def make_averager():
    count=0
    total=0
    
    def averager(new_value):
        nonlocal count,total
        count+=1
        total+=new_value
        return total/count
    return averager
```

If no `nonlocal`definition, `count+=`actually means that the same as `count=count+1`-- when `count`is a number or immutable type -- actually assigining to `count`in the body of the `averager`-- this makes it a local variable. Did not have this problem cuz never assigned to the `series`list -- only called `series.append`. But with immutable types like numbers, strings, tuples, etc -- you U can do is read, never update -- if try to rebind them, as in `count=count+1`-- then you are implicitly creating a local variable `count`, it is no longer a free variable, and therefore it is not saved in the closure.

So, to work around this, the `nonlocal`keyword was introduced in py3.

### Variable Lookup logic

When a function is defined, the py bytecode compiler determines how to fetch a variable x that happens in ti.

- If there is a global `x`-- comes from and is assigned to the global module.
- if there is a `nonlocal`x declaration --  comes from and is assigned to the `x`local variable of nearest surrounding function where `x`is defined.

### Implementing a simple Decorator

```py
import time


def clock(func):
    def clocked(*args):
        t0 = time.perf_counter()
        result = func(*args)
        elapsed = time.perf_counter() - t0
        name = func.__name__
        arg_str = ', '.join(repr(arg) for arg in args)
        print(f'{elapsed:0.8f}s {name}({arg_str}) -> {result!r}')
        return result

    return clocked
```

for the `result=func(*args)`-- this line only works cuz the closure for `clocked`encompasses the `func`free variable. Need to return the inner function returns the result.

Just remember that this code :

```py
@clock
def factorial(n):
    return 1 if n<2 else n*factorial(n-1)
```

So in both examples, `clock`get the `factorial`function as its `fucn`argument.

`factorial=clock(factorial)`In both examples, `clock`just gets the `factorial`function as its `func`argument then creates and returns the clocked function, which the Python interpreter assigns to `factorial`. In fact, if you import the module.

For this, has a few shortcomings -- it does not support keyword arguments, and it masks the `__name__`and `__doc__`of the decorated functions -- uses the `functools.wraps`decorator to copy this: like:

```py
def clock(func):
    @functools.wraps(func)
    def clocked(*args):
        #...
```

`functools.wraps`is just one of the ready-to-use decorators in the stdlib.

### Decorators in the STDLIB

Py has 3 built-in functions that are designed to decorate methods -- `property, classmethod, staticmethod`

The `functools.cache`decorator implements *memoization* -- an optimization tecnique that works by saving the results of previous invocations of an expensive function like:

```py
@clock
def fibonacci(n):
    if n < 2:
        return n
    return fibonacci(n - 2) + fibonacci(n - 1)
```

For this, waste is obvouis -- `fibonacci(1)`is just called 8 times, just use the `functools.cache`module like: Need to note the order is just important!

```py
@functools.cache
@clock
def fibonacci(n):...
```

### Single Dispatch generic functions

Fore, creating a tool to debug web applications, want to generate HTML displays for different types of PY objects fore:

```py
import html
def htmlize(obj):
    content= html.escape(repr(obj))
    return f'<pre>{conent}</pre>
```

for `str`, replace embedded newline characters with `<br />\n`and use `<p>`tags instead of `<pre>`. For `int`show the number in decimal and hexadecimal, for `list`, output an html list, for `float and decimal`-- output the value as usual

### Function singledispatch

Don't have overloaded method.. A possible solution in py would be turn the `htmlize`into a dispatch function, just with a chain of `if/elif`or `match/case`-- this is not extensible by users of our module, and is unwiledy.

The `functools.singledispatch`decorator allows different modules to contribute to the overall solution, and lets you easily provide specialized functions even for types that belong to 3rd-party packages that you can't edit.

If decoraate a plain function with `@singledisptch`, becomes the entry point for *generic function* A group functions to perform the same operation in different ways, depending on the type of the first argument like:

```py
from functools import singledispatch
from collections import abc
import fractions
import decimal
import html
import numbers


@singledispatch
def htmlize(obj: object) -> str:
    content = html.escape(repr(obj))
    return f'<pre>{content}</pre>'


@htmlize.register
def _(text: str) -> str:
    content = html.escape(text).replace('\n', '<br />\n')
    return f'<p>{content}</p>'


@htmlize.register
def _(seq: abc.Sequence) -> str:
    inner = '</li>\n</li>'.join(htmlize(item) for item in seq)
    return '<ul>\n<li>' + inner + '</li>\n</ul>'


@htmlize.register
def _(n: numbers.Integral) -> str:
    return f'<pre>{n} (0x{n:x})</pre>'
```

1. `@singledispatch`marks the base function that handles `object`type
2. each specialized function is just decorated with `@base.register`
3. The type of the first arg given at runtime determines when this particular function definition will be used. The name of the specialized functions is irrelevant -- `_`is just good choice.

### Parameterized Decorators

When parsing a decorator in source code, py takes the decorated function and passes it as the first argument to the decorator function -- Make a decorator factory that takes those arguments and returns a decorator. To make it easy to enable or disable the function registration performed by `register`, we will make it accept an optional `active`parameter -- if `False`, skips registering the decorated function -- like:

```py
registry = set()


def register(active=True):
    def decorate(func):
        print('running register' f'(active={active}) -> decorate({func})')
        if active:
            registry.add(func)
        else:
            registry.discard(func)
        return func

    return decorate


@register(active=False)
def f1():
    print("running f1()")
# f1 = register(active=False)(f1)

@register()
def f2():
    print('running f2()')
```

### A class-based Clock Decorator

Just implement the `__call__`method like:

```py
class clock:
    def __call__(self, func):
        def clocked(*_args):
            ...
        return clocked
```

## Design patterns wtih first-class functions

### Object Representations

Every oop has at least one std way of getting a string repr -- in py has two:

- `repr()`-- returns a string represenation the object as the developer wants to see
- `str()`-- return a string representing the object as the user wants to see it.

And , there are two additional special methods to support alternative representations of the objects like `__bytes__`and `__format__`-- the `__bytes__`method is -- to `__str__`-- just called by `bytes()`to get the object represented as a byte sequence.And the `__format__`for the built-in function `format()`.

In order to demonstarte the many methods used to generate object representations, use the `Vector2d`class:

```py
from array import array
import math


class Vector2d:
    typecode = 'd'

    def __init__(self, x, y):
        self.x = float(x)
        self.y = float(y)

    def __iter__(self):
        return (i for i in (self.x, self.y))

    def __repr__(self):
        class_name = type(self).__name__
        return f'{class_name}({self.x!r}, {self.y!r})'

    def __str__(self):
        return str(tuple(self))  # easy to just build a tuple for display

    def __bytes__(self):
        return (bytes([ord(self.typecode)]) +
                bytes(array(self.typecode, self)))

    def __eq__(self, other):
        return tuple(self) == tuple(other)

    def __abs__(self):
        return math.hypot(self.x, self.y)

    def __bool__(self):
        return bool(abs(self))
```

Just note that the `__repr__`builds a string by interpolating the components with `{!r}`to get their repr.

### An alternative Ctor

Since, can export a `Vector2d`as bytes, naturally need just a method that imports a `Vector2d`from a binary sequence, we find that the `array.array`has a class mehod called `.frombytes`-- like:

```py
@classmethod
def frombytes(cls, octets):
    typecode= chr(octets[0])
    memv = memoryview(octets[1:]).cast(typecode)
    return cls(*memv)
```

### Classmethod vs. Staticmethod

The `classmethod`decorator is not mentioned in py -- and neither is `staticmethod` define a method that just operates on the class and not on instance. its most common use is for alternative ctors, like `frombytes`-- note how the last line of actually uses the `cls`arg by invoking to build a new instance.

In contrast, the `staticmethod`decorator changes a method so that it receives no special argument. In essence, a static method is just like a plain function that happens to live in a class body, instead of being defined at the module level.

```py
class Demo:
    @classmethod
    def klassmethod(*args):
        return args
    
    @staticmethod
    def statmeth(*args):
        return args
```

### Formatted Displays

The f-strings, the `format()`built-in function and `str.format()`method delegate the actual formatting to each type by calling their `.__format__(format_spec)`method.

- The second argument in `format(my_obj,format_spec)`or
- Whatever appears after the colon in a replacement filed delimited with `{}`inside a f-string.

## Packaing applications from source code into Docker images

Building Docker images is easy -- just learned just need a few instructions in a Dockerfile to package an appliation to run in a container -- There is one other thing you need to know to package your own applications -- Commands executed during the build and any filesystem changes from the command are saved in the image layer. That just makes Dockerfiles about the most flexible packaging format ther is -- can just expand ..

Start a simple example -- cuz there are a couple of new things to understand in the process.

```Dockerfile
FROM diamol/base AS build-stage
RUN echo 'Building...' > /build.txt

FROM diaml/base as test-stage
COPY --from=buid-stage /build.txt /build.txt
RUN echo 'Test...' >> /build.txt

FROM diamol/base
COPY --from=test-stage /build.txt /build.txt
CMD cat /build.txt
```

This is just called **multi-stage** Dockerfile -- cuz there are several stages to the build, each stage starts with the `FROM`instruction, and can optionally give stages a name with the `AS`parameter -- 3 stages -- `build-stage, test-stage`and the final unnamed stage.

Note -- each stage run independently -- can just copy files and directories from previous stages -- Use the `COPY`with the `--from`argument, which tells Docker to copy files from an earlier stage in the Dockerfile, rather than from the filesystem of the host computer.

There is a new -- `RUN`command -- Using to write files, the `RUN`executes a command inside a container during the build, and any output from that command is saved in the image layer. Can just execute anyting in a `RUN`instruction, but the commands you want to run need to exist in the `Docker`image -- u are using in the `FROM`instruction. So, just used the `diamol/base`as the base image, and it contains the `echo`.

It’s just important to understand that the individual stages are isolated -- can use different base images with different sets of tools installed and run whatever commands you like.  And the final stage will only contain what you explicitly copy from earlier stages. -- If a command fails in any stage, the whole build fails.

### App walkthrough Node.js source code

goint to go through another multi-stage Dockerfile, this time for a `Node.js`app -- Java applications are just compiled, so the source code gets copied into the build stage, and need that generates a JAR file -- JAR is the complied app, and it gets copied into the final app image -- same with `.NET core`where the compiled artifacts are just DLLs. Node.js is different -- uses Js -- interpreted lang. like:

There is still a need for a multi-stage Dockerfile though, it optimizs dependency loading. Node.js uses a toll called `npm`to mange dependencies.

```Dockerfile
FROM diamol/node AS builder

WORKDIR /src
COPY src/package.json .
RUN npm install

# app
FROM diamol/node

EXPOSE 80
CMD ["node", "server.js"]

WORKDIR /app
COPY --from=builder /src/node_modules/ /app/node_modules/
COPY src/ .
```

The goal here is the same as for the Java application -- to package and run the app with only Docker installed, without having to insstall any other tools. Note that the base image for both stags is `diamol/node`which has the `Node.js`runtime and npm installed. The last thing is to create a working directory and copy in the app artifacts. The downloaded dependencies are copied from the build stge, and the source code is copied from the host computer. And the `src`folder contains just the js files, including `server.js`, which is the entry point started by the node.js process.

So have a different technology stack here -- with jsut different pattern for packaging the application.

```sh
docker image build -t access-log .
docker container run --name access-log -d --port 801:80 
```

Containers access each other across a virtual network using the virtual IP address that Docker allocates when it creates the container-- can create and manage virrual Docker networks through command line like:

```sh
docker network create nat
```

Now when you run containers U can explicitly connect them the the Docker network using the `--network`flag, and any containers on that network can reach each other using the container names.

### Go source code

For a web app written in go, but Go just has the widest platform support, it’s also very popular for cloud-native apps.

```Dockerfile
FROM diamol/golang AS builder
COPY main.go .
RUN go build -o /server

FROM diamol/base

ENV ...
CMD ["/web/server"]

WORKDIR web
COPY index.html .
copy --from=builder /server .
RUN chmod +x server
```

Go just impiles to native binaries, so each stage in the Dockerfile uses a different base image.

```sh
docker image build -t image-gallery .
```

This Go application does do sth useful, but before you run it, worth taking a look at the size of the images like:

```sh
docker image ls -f reference=diamol/golang -f reference=image-gallery
```

This command lists all images and filters the output to only include images with a reference of `diamol/golang`or `image/gallery`. like.

## Intercepting and changing Actions

Want to run code when certain actions take place with an object, but don’t want to put your code *inside* the object. The `Proxy`class allows you to intercept a variety of different actions on any object. The following example uses a proxy to perform validation on an object named `product`.

```js
const product = { name: 'banana' };

// This is the handler that the proxy uses to intercept traps
const propertyChecker = {
    set: function (target, property, value) {
        if (property === 'price') {
            if (typeof value !== 'number') {
                throw new TypeError('price is not a number');
            } else if (value <= 0) {
                throw new RangeError('price must be greater than zero');
            }
        }
        else if (property !== 'name') {
            throw new ReferenceError(`property '${property}' not valid`);
        }
        target[property] = value;
    }
};

// then create the proxy
const proxy = new Proxy(product, propertyChecker);
proxy.name = 'apple'; //nodify the product object through the proxy
// proxy.type = 'red delicious';// throw
proxy.price = -100; // also throw
```

The `Proxy`object just wraps an object and can be used to *trap* specific actions, and then provide additional or alternative behaviors based on the action and object’s data at the time of the action.

### Cloning an object

want to create an exact copy of a custom object -- Using the spread operator `...`to unpack you object into a collection of properties, and put that prop list insdie the `{}`to buld a new object like:

```js
const animal = {
    name:'fox', class:'mammalia', order:'carnivor',
}
const animalCopy = { ...animal };
console.log(animalCopy)
```

When just using the spread operator, get all *enumerable* properties of an object. this include all the properties you create using object literal syntax, or any new prop you assign after the fact -- however, you can specially choose to create nonenumerable pops using the `Object.definProperty()`method.

May see - `const animalCopy= Object.assign({}, animal)`;

Either way -- these operations perform just a *shallow* copy, if object includes arrays or other objects as properties, these details won’t be copied -- instead, they will be *shared* between the original object and the new object.

### Making a Deep Copy of an object

Want to create an exact copy of a custom obeject, you want to just copy not just the top-level object, but also every object it references -- There is no single solution for deep copying an object. Instead, there are a variety of techniques that developers use, each with own trade-offs.

The safest is to write own cloning logic that is specific to the type of object you want to clone -- Here is an example that makes a deep copy of the `student`object like:

```js
function cloneStudent(student) {
    const studentCopy= {...student};
    studentCopy.testScore=[...studentCopy.testScores];
    return studentCopy;
}
```

If you are making a full-fledged class, consider making your custom cloning funtion a method of the class itself. FORE:

```js
class Student {
    constructor(firstName, lastName, testScores){
        this....;
    }
    clone(){
        return new Student(this...., [...this.testScore]);
    }
}
```

### Creating abs unique Object Property keys 

Wan to add a uniquely named property to an object, and you want to guaranteed that it won’t clash with other property name -- create a new property name just using `Symbol`type -- then use that name to set the property like:

```js
const newObj = {};

// Set a unique property that will never clash with anything else
cosnt uniqueId= Symbol();
newobj[uniqueId]='no two alike';
```

And never actually see the unique identifier that the `Symbol`type uses -- In this example, there is the output you will get in the console. like `{Symbol(): ...}`-- To access, just need to keep track of Symbol name like:

`newObj[uniqueId]`

Optionally, can give your symbols a description -- which is useful just for debugging -- like:

```js
const propertyName= Symbol("log status");
newObj[propertyName]="logged";
```

### Creating Enum with Symbol

want to just store a small, related group of constants - so can refer to them by name in your code like:

```js
const TrafficLight = {
    Green: Symbol('green'),
    Red: Symbol('red'),
    Yellow: Symbol('yellow'),
}

// This func uses the light enum
function switchLight(newLight) {
    if (newLight === TrafficLight.Green) {
        console.log('light green');
    }
    //...
    return newLight;
}
```

So an `enum`is a group of named constants. enums are useful anytime you have a variable that can only take a small set of allowed values. If you don’t have a natural unique value to use for your constants, consider using a `Symbol` -- this saves you from needing to pick your own arbitrary numbers -- and the guaranteed uniqueness of every `Symbol`ensures that you can’t subsitute any other value.

The drawback to using `Symbol`is that the underlying value is completely opaque.

## Classes

In js -- depends on how -- OOP resolve around concepts like classes, interfaces, and inheritance -- Js is using `prototype`-- Then along came just ES6, and all of sudden classes were available as a native language consturct - ES6 classes are just a higher-level language feature built on the familar foundation of Js propertypes, The mapping is not exact, and the class model-- 

The bottom line is -- new development favors using classes -- but, prototype based code is still common.

### Creating a Reusable Class

```js
class Person {
    constructor(firstName, lastName, dateofBirth) {
        this.firstName=firstName;
        //...
    }
    swapNames(){
        [this.firstName, this.lastName]=[this.lastName, this.firstName];
    }
}
```

Class just have their own syntax requirements that you must follow -- 

- Consturctor functions are always named `constructor`.
- Neither ctors nor methods use the keyword `function`.

Extra: Multiple cotrs

In most oop language it’s just possible to create multiple ctors, so the code that creates the class has a choice of what parameters to speify -- but Js doesn’t support ctor overloading or method overloading -- 

This isn’t quite as limiting as it seems, cuz Js is notoriously loose iwth function arguments and never forces you to supply them -- 

```js
const p1 = new Person("Luke", "takei");
const p2 = new Person('Luke');
const p3 = new Person();
```

For this, every class has just exactly one ctor, and it always runs -- even if you don’t specify any arguments when create a `Person`object, the 3-argument ctor still runs and set `this.firstName` -- others which will be just set to `undefined`-- if this isn’t acceptable, can set default parameter values.

And, another way to deal with optional args is using an object literal that gets passed to the ctor -- that way the caller can choose to set only the named properties want to use like:

```js
const partialInperson1 = new Person( {
    lastName: ..., 
    birthDate: new Date(...)
});
```

This is a common js design pattern. The disadvantage is that there is nothing to prevent you from accidently creating incorrectly named paramters that will be just silently ignored like:

`const partialInfoPerson2= new Person({firstname: 'luke'})`

### Adding Properties to a class

Want to just add property getters and setters to wrap your class data. Just need to consider if properties are the best solution for your use case. If decide to use properties, can just create `get`and `set`methods for each one. like:

```js
class Person {
    constructor(firstName, lastName, dateOfBirth) {
        this....
    }
    get age() {
        //...
        return age;
    }
}
```

It’s up to you whether U include only a getter, a setter.. like:

```js
class person{
    constructor(...) {}
    get dateOfBirth() {
        return this._dateOfBirth;
    }
    set dateOfBirth(value){
        if...
    }
}
```

There are just many reasons you might consider creating property procedures -- some example include -- 

- To calculate a value
- To transform a filed into another representation.
- To perform validation before updating a field.
- Add hooks for some other service
- To use some kind of lazy initlization.

#### Extra: Private Fields

Currently, js does not have a way to make member varible private -- Right now, the private filed synax uses a `#`to identify the private fields -- which can be declared at the beginning of your class block, making your class itself documenting. like:

```js
class Person {
    #firstName;
    #lastName;
    constructor(firstName, lastName){
        this.#firstName=firstName;
        // ...
    }
	get firstName(){
        return this.#firstName;
    }
	set firstname(value){
        this.#firstName=value;
    }
}
```

## Anatomy of a grid

It’s important to understand the various parts of grid -- 4 other important terms to know are illustrate:

- Grid line -- These makes up the structure of the grid, a grid line can be vertical or horizontal and line on either side of a row or column - -the grid-gap, lies atop the grid liens.
- Grid track -- is a space between two adjacent grid lines.
- Grid cell -- a single space on the grid
- Grid area -- A rectangle area on the grid made up by one or mroe grid cells.

The `ng`command is part of the `@angular-cli`package, and `ng new`sets up a new project, the argument configure the project, selecting options that are suitable for a first project.

### Adding Features to the Application

The starting point for most applications is the data model, which describes the domain on which the application operates -- Data models can be large and complex -- but for app need to describe only two things -- a to-do item and a list of those items

```tsx
export class TodoItem {
  constructor(public task:string, public complete: boolean=false) {
    // no statements required
  }
}

```

The language features are a mix of std Js features and extra features that Tsc provides -- when the code is compiled, the Tsc features are removed, and the result is just Js code that can be executed by the borwsers.

The `export`relates to Js modules, when using modules, each Ts or Js file is considered to be a self-contained unit functionality and the `export`keyword is used to identiy data or types that you want to use elsewhere in the app. js modules are used to manage the dependencies that arise between files in a project.

The values of these parameters are assiigned to `public`properties of the same names -- if no value is provided for the complete parameter, then a default false will be used.

This concise ctor avoids a block of boilerplate code that would otherwise be required to define props and assign them values that are received by the ctor.

### Creating the To-do List class

```tsx
export class TodoList {
  constructor(public user: string, private todoItems: TodoItem[]=[]) {
  }
  
  get items(): readonly TodoItem[] {
    return this.todoItems;
  }
  
  addItem(task: string) {
    this.todoItems.push(new TodoItem(task));
  }
}
```

The `import`declares a dependency on the `TodoItem`class -- the `TodoList`class defines a ctor that receives the initial set of to-do items -- don’t want to give unrestricted access to the array of `TodoItem`objects. Defined the prop `items`that returns a read-only.

### Displaying Data to the User

Need a way to display the data values in the model to the user -- using *template* -- which is a fragment of HTML that contains expressions that are just evaluated by Ng and that inserts the results into the content that is sent to the browser.

```html
<h3>
  {{username}}'s To Do List
  <h6>{{itemCount}} Items</h6>
</h3>
```

The `{{}}`just are an example of a *data binding*, which means they create a relationship between the template and data value. Cuz the expressions within the data bindings rely on properties that don’t exist -- fix -- 

### Updating the Component

and an Ng *component* is responsible for managing a template and providing it with the data and logic it needs. If that seems like a broad statement -- cuz components are the part of an Angular app that does most of the heavy lifting. In this case, need a component to act as a bridge between the data model classes and the template so that can create an instance of the `ToDoList`class -- populate it with some sampel objects, and in doing so, provide the template with the `username`and `itemCount`properties it needs.

When project was created the `ng new`command added a file named `app.component.ts`to the app folder like:

```tsx
@Component({
  selector: 'app-root',
  templateUrl: './app.component.html',
  styleUrls: ['./app.component.css']
})
export class AppComponent {
  private list = new TodoList("Bob", [
    new TodoItem("Gor for run", true),
    new TodoItem("Get flowers"),
    new TodoItem("Collect tickets"),
  ]);

  get username(): string {
    return this.list.user;
  }

  get itemCount(): number {
    return this.list.items
      .filter(item => !item.complete).length;
  }
}

```

### Understanding the Imports

The `import`keyword just decalres dependencies on js modules, both within the project and in 3rd-party packages, and the `import`keyword is used 3 times. For the `@angular/core`module, which contains the key Angular functionality, including support for components -- when working with modules, the `import`specifies the types that are imported between curly braces -- in this case, the `import`statement is used to load the `Component`type from the module.

The Decorator -- like:

```tsx
@Component ({
    selector: "app-root",
    templateUrl: '...html',
    styleUrls: ['.app.component.css']
})
```

which provides metadata about a class, this is the `@Component`decorator, and as its anem suggests, it tells Ng that this is a component, the decorator provides configuration info through its properties, this `@Component`specifies selector, templateUrl and `styleUrl` -- The `selector`just speicifies a CSS selector that matches the HTML element to which the component will be applied.

When request to the website, the browser receives the contents of the `index.html`file -- which was added to the `src`folder when the project was created, this file contains a custom HTML element, like:

`<app-root></app-root>`

When the Ng code is executed, the value of the `selector`property defind by the component is sued to locate the specified element in the HTML document.

The `templateUrl`is to specify the component’s template -- which is just the `app.component.html`file.

These statements define a class called `AppComponent`thtat has a private `list`prop, which is assigned to a `TodoList`object and is populated with an array of `TodoItem`objects.

### Styling the application Content

To style the HTML content produced by the appliation, going to use the Ng Material package -- which contains a set of components for use in Angular applications -- Ng material is *official* component library like:

```sh
ng add @angualr/material --default
```

Applying components -- just use components contained in the package to style the conent produced by the app. The new template content relies on features from the ng material package, each of which is applied differently.

```html
<mat-toolbar color="primary" class="mat-elevation-z3">
  <span>{{username}}'s To Do list</span>
  <mat-icon matBadge="{{ itemCount }}" matBadgeColor="accent">Checklist</mat-icon>
</mat-toolbar>
```

The new template content reles on features from the Ng material package, each of which is applied differently.

### Defining the spacer CSS style

The Ng material package is generally comprehensive, but one omission is spacers to help just position content. Want to position the `span`element that contains the user’s name centrally within the title bar and have the icon and badge appear on the right. `styleUrls.css`-- which like;

`.spacer {flex: 1 1 auto}`

```html
<mat-toolbar color="primary" class="mat-elevation-z3">
  <span class="spacer"></span>
  <span>{{username}}'s To Do list</span>
  <span class="spacer"></span>
  <mat-icon matBadge="{{ itemCount }}" matBadgeColor="accent">Checklist</mat-icon>
</mat-toolbar>
```

### Displaying the List of To-Do Items

The next step is to display the to-do items add property to the component that provides access to the items.

```tsx
get items(): readonly TodoItem[] {
    return this.list.items;
}
```

And, to display details of each item to the usre, going to use the materal table component -- which makes it easy to present theuser with tabular data like:

```html
<div class="tableContainer">
  <table mat-table [dataSource]="items" class="mat-elevation-z3 fullWidth">
    <ng-container matColumnDef="id">
      <th mat-header-cell *matHeaderCellDef>#</th>
      <td mat-cell *matCellDef="let i = index">{{i + 1}}</td>
    </ng-container>

    <ng-container matColumnDef="task">
      <th mat-header-cell *matHeaderCellDef>Task</th>
      <td mat-cell *matCellDef="let item">{{item.task}}</td>
    </ng-container>

    <ng-container matColumnDef="done">
      <th mat-header-cell *matHeaderCellDef>Done</th>
      <td mat-cell *matCellDef="let item">{{item.complete}}</td>
    </ng-container>

    <tr mat-header-row *matHeaderRowDef="['id', 'task', 'done']"></tr>
    <tr mat-row *matRowDef="let row; columns: ['id', 'task', 'done'];"></tr>
  </table>
</div>
```

### Creating a two-way Data binding

At the moment, the tempalte contains ony one-way *data binding*-- which means that they are used to display a data value but are unable to change it. Angular also supports *two-way data binding* can be used to display a data value and change it too.

```html
<td mat-cell *matCellDef="let item">
    <mat-checkbox [(ngModel)]="item.complete" color="primary">
        {{item.complete}}
    </mat-checkbox>
</td>
```

The `mat-checkbox`element applies the Ng Material checkbox component, the two-way binding is expressed like: The combination of brackets is just known as the *banana-in-a-box* cuz the round look like a ...

### Filtering Completed To-Do items

The checkboxes allow the data model to be updated, and the next step is remove to-do items once they have been marked as done -- changes the component’s items property so that it filter out any items that has been completed.

```tsx
get items(): readonly TodoItem[] {
    return this.list.items.filter(item=>!item.complete);
}
```

### Adding To-do items

A to-do app isn’t much use without the ability to add new items to the list -- uses Angular Mateial components to present the user with an input element, into which a task description can be entered.

```cs
addItem(newItem: string) {
    if (newItem != "")
        this.list.addItem(newItem);
}
```

```html
<div class="inputContainer">
  <mat-form-field class="fullWidth">
    <mat-label style="padding-left: 5px;">New To Do</mat-label>
    <input matInput placeholder="Enter to-do description" #todoText>
    <button matSuffix mat-raised-button color="accent" class="addButton"
            (click)="addItem(todoText.value); todoText.value=''">
      Add
    </button>
  </mat-form-field>
</div>
```

Note that the `input`element has an attribute whose name starts with `#`-- refer to the element in the template’s data bindings -- The name of the variable is just `todoText`and it is used by the binding that has been applied to the `button`element.

### Fininshing Up

The basic features are in place, and now it is time to wrap up the project -- removed the `true/faslse`text from the Done.

## Classes

The world of Js during Ts’ creation and release in the early 2010s was quite different from today. Features such as arrow function and `let/const`variables that would later be standardized in es 2015 were still distant hopes on the horizon -- 

### Class Methods

TypeScript generally understands methods the same way it understands standalone functions. Parameter types default to `any`unless given a type or default value; calling the method requires an acceptable number of arguments; return typs can generally inferred if the function is not recursive.

This code snippet defines a `Greeter`class with a `greet`class method that takes in a single required parameter of type `number`:

```tsx
class Greeter {
    greet(name:string){
        console.log(`${name}, do your stuff`);
    }
}
```

Class cotrs are treated like typical class methods with regards to their parameters. Ts will perform type checking to make sure a correct number of arguments with correct types are provided to method calls.

### Class Properties

To read from or write to a property on a class in Ts, must be expclicitly declared in the class. Ts will not attempt to deduce what members may exist on a class from their assignment in a ctor.

Function Properties -- Recap some Js method scoping and syntax fundamentals for a bit, as they can be surprising if you are not accustomed to them. Js contains two syntaxes for declaring a member on a class to be a callable function to the class prototype -- so all instances use the same function definition.

The `withMethod`class declares a `myMethod`method that all instances are able to refer to:

### Initialization Checking

With strict compiler settings enabled, Ts will check that each property declared whose type does not include `undefined`is assigned a vlaue in the constructor. Like:

```tsx
class WithValue {
    immediate=0; //ok
    later:number;
    maybeUndefined: number | undefined; //ok too
    unused: number; // error
    constructor(){
        this.later=1;
    }
}
```

Without strict initialization checking, a class instance could be allowed to access a value that might be `undefined`even though the type system says it can’t be.

This example would compile happily if strict initialization checking didn’t happen, but the resultant Js would crash at runtime -- 

```tsx
class MisingInitializer {
    property: string;
}
new MissingInitializer().property.length; // TypeError
```

### Definitey assigned properties

Although strict initialization checking is useful most of the time, may come across some cases where a class property is intnetionally able to be unassigned after the class ctor. If U are absolutely sure a property should not have strict initialization checking applied to it, can add ! after its name to disable the check.

```tsx
class ActivitiesQueue {
    pending!: string[];
	initialize(pending: string[]){
        this.pending = pending;
    }
	next(){ return this.panding.pop();}
}
const activities = new ActivitiesQueue();
acitivities.initialize(['eat', 'sleep', 'learn']);
```

### Optional Properties

Much like interfaces, classes in Ts may declare a prop as optional by adding a `?`after declaration name. Optional properrties behave roughly the same as properties whose types happen to e a union that includes `|`undefined.

```tsx
class MissingInitializer {
    property?: string;
}
new MissingInitializer().property?.length;
new MissingInitializer().property.length; //error
```

### Read-only Properties

Again much like interfaces, classes in Ts may declare a property as read-only by adding the readonly by adding the `readonly`keyword before its declaration name. The `readonly`keyword exists purely within the type system and is removed when compiling to Js.

Properties declared as `readonly`may only be assigned initial values where they are declared or in a ctor. Any other location -- including methods on the class itself -- may only read from the properties not write to them.

```tsx
class Quote {
    readonly text :string;
    constructor(text: string) {
        this.text= '';
    }
    emphasize() {
        this.tex += "!";
    }
}

const quote = new Quote(
	"There is a billiant child locked inside every student."
);
quote.text= "ha!"; // error: cannot assign to 'text' cuz it is a read-only property.
```

External users of your code, such as consumes of any npm packages U published, might not respect *readonly* modifiers -- espicially if they are writing Js and don’t have type checking.

Properites declared as `readonly`with an initial value of a primitive have a slight quirk compared to other properties: they are inferred to be their value’s narrowed *ltieral* type if possible, rather than the wider *primitive*. Ts feels comfortable with a more aggressive initial type narrowing cuz it knows the value won’t be changed later; it is similar to `const`variables taking on narrower types than `let`variables.

In this example, the class properties are both initially declared as a string literal, so in order to widen one of them to `string`, a type annotation is needed.

```tsx
class RandomQuote {
    readonly explicit: string = "home is the nicest word there is."
    readonly implicit = "home is nicest word there is";

    constructor() {
        if (Math.random() > 0.5) {
            this.explicit = "we start learning the minute we're born";
            this.implicit = "start learning";// error
        }
    }
}
```

