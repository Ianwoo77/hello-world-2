# Using Regualr Expressions(2)

The `regexp`package provides support for regular expressions, which allow complex patterns to be found in strings.

`Match`, `MatchString(pattern, s)`, `Compile`, `MustCompile`.

```go
func main() {
	text := "It was a boat. A Small boat."
	match, err := regexp.MatchString("[a-z]oat", text)
	if err == nil {
		fmt.Println("Match", match)
	} else {
		fmt.Println("Error:", err)
	}
}

```

## Compiling and Reusing Patterns

The `MatchString`is simple and convenient, but the full power of regexp is accessed through the `Compile`function.

```go
func main() {
	pattern, compileErr := regexp.Compile("[A-z]oat")
	desc := "A boat for one person"
	question := "Is that a goat?"
	preference := "I like oats"

	if compileErr == nil {
		fmt.Println("Desc:", pattern.MatchString(desc))
		fmt.Println("Question:", pattern.MatchString(question))
		fmt.Println("Preference:", pattern.MatchString(preference))
	} else {
		fmt.Println("Error:", compileErr)
	}
}
```

This is more efficient cuz the pattern has to compiled only once, The result of the `Compile`function is an interface of the `Regexp`type, which defines the `MatchString`.

Compiling a pattern also provides access to methods for using regular expression features, the most useful of which -- The methods in this -- 

`MatchString(s)`, `FindStringIndex(s)`, `FindAllStringIndex(s, max)`, `Split`

## Splitting Strings using a regular Expression

The `Split`method splits a string using the matches made by a regular expression, which can provide a more flexible alternative to the splitting function described -- like:

```go
func main() {
	pattern := regexp.MustCompile(" |boat|one")
	desc := "Kayak. A boat for one person."
	split := pattern.Split(desc, -1)
	for _, s := range split {
		if s != "" {
			fmt.Println("Substring", s)
		}
	}
}

```

## Using subexpressions

SubExpression allow :

```go
func main() {
	pattern := regexp.MustCompile("A [A-z]* for [A-z]* person")
	desc := "Kayak. A Boat for one person."
	str := pattern.FindString(desc)
	fmt.Println("Match:", str)
}
```

The pattern in this example matches a specific sentence structrure. Which allows me to match the part of a string that is of interest. Can add subexpressions to identify the regions of content that are important within the pattern like:

```go
func main() {
	pattern := regexp.MustCompile("A ([A-z]*) for ([A-z]*) person")
	desc := "Kayak. A Boat for one person."
	strs := pattern.FindStringSubmatch(desc)
	for _, str := range strs {
		fmt.Println("Match:", str)
	}
}
```

Subexpressions are denoted with partentheses, Have defined two subexpressions, each of which surrounds a variable section of the pattern, and the `FindStringSubMatch`method just performs the same task as `FindString`.

## Named Subexpressions

Subexpressions can be given names, whcih makes the regular expression harder to understand but makes the results easier to process like:

```go
func main() {
	pattern := regexp.MustCompile("A (?P<type>[A-z]*) for (?P<capacity>[A-z]*) person")
	desc := "Kayak. A Boat for one person."
	strs := pattern.FindStringSubmatch(desc)
	for _, name := range []string{"type", "capacity"} {
		fmt.Println("Match:", strs[pattern.SubexpIndex(name)])
	}
}
```

## Replacing Substrings using regexp

The final set of `RegExp`metghods -- 

`ReplaceAllString(s, template)`, `ReplaceAllLiteralString` Like:

```go
template := "(type: ${type}, capacity: ${capacity})"
replaced := pattern.ReplaceAllString(desc, template)
fmt.Println(replaced)
```

The result from the `ReplaceAllString`method is a string with the replaced content -- The template can refer to matches made for subexpressions by name. Or by position: `${type}`, or `${1}`

## Replacing Matched Content with A function

The `ReplaceAllStringFunc`replaces the matched section of a string with content generated by a function. like:

`replaced := pattern.ReplaceAllStringFunc(desc, func(s, string) string {return “this is replaced string”})`

## DefaultServeMux

The `DefaultServeMux`is a global variable, any package can access it and register a route -- including any 3rd-party packages that your application imports. If one of those 3rd-party package is compromised, They could use `DefaultServeMux`to expose a malicious handler to the web.

So, for the sake of security, it’s generally a good ida to avoid `DefaultServeMux`.

Quirks -- 

- In Go, longer URL patterns always take precedence over the shorter one.
- Request URL paths are automatically sanitized.
- If a subtree path has been registered and a request is received for that subtree without trailing, auto be sent to a 301. if `/foo/`, then request to `/foo`, will be redirected to `/foo/`, note that.

## Host Name Matching

It’s possible to include host names in your URL patterns -- This can be useful when you want to redirect all HTTP requests to a canonical URL.

## Customizing HTTP headers

Now just update app so that the `/snippet/create`only responds to HTTP requests using `POST`. like:

```go
func createSnippet(w http.ResponseWriter, r *http.Request) {
	if r.Method != http.MethodPost {
		w.WriteHeader(http.StatusMethodNotAllowed) // 405
		w.Write([]byte("Method Note allowed"))
		return
	}
	w.Write([]byte("Create a new Snippet..."))
}
```

There are just a couple of nuances -- 

- It’s only possible to call `w.WriteHeader`once per response, and after the status code has been written, it can’t be chagned.
- If dont’ call `w.WriteHeader()`expclicitly, then the first call `w.Write()`will automatically send a 200.

## Customizing Headers

Another improvement can make is to include an `Allow: POST`header with every 405 response to let the user just know which request methods are supported for that particular URL.

Can do so by using the `w.Header().Set()`method like:

`w.Header().Set(“Allow”, http.MethodPost)`

## The `http.Error`Shortcut

If want to just send a non-200 status code and a plain-text response body, use the `http.Error()`shortcut. like:

`http.Error(w, "Method not allowed", http.StatusMethodNotAllowed)`

In terms of functionality this is most exactly the same -- The biggest difference is that we are now passing our `http.ResponseWriter`to another function, which sends a response to the user for us.

The patternof passing `http.ResponseWriter`to other functions is just common in Go -- and sth.

## Additional Info - Manipulting the Header Map

`w.Header().Set()`to add a new header to the response header map. like:

```go
// Set a new cache-control header
w.Header().Set("Cache-control", "public...")

// delete all values for `Cache-Control`
w.Header.Del("Cache-Control")

// Retrieve the first value
w.Header.Get("Cache-Control")
```

When sending a response Go will automatically set three system-generated headers for you: `Date`, `Content-Length`and `Content-Type`.

Go can attempt to set the correct one for you by content sniffiling -- with `http.DetectContentType`.

## Suppressing System-Generated Headers

The `Del`method -- doesn’t remove headers, to supress, need to acces the underlying map directly and set the value to `nil`. like:

`w.Header()[“Date”]=nil`

## URL Query Strings

Update the `showSnippet`and accepts an `id`query string parameter like:

`/snippets?id=1`

And, to make this work need to update the `showSnippet`handler function to do two things -- like:

1. Needs to retrieve the value of the `id`parameter from the URL query string -- `r.URL.Query().Get()`method.
2. Cuz the `id`is untrusted, should validate it to make sure it’s sane and sensible.

```go
func showSnippet(w http.ResponseWriter, r *http.Request) {
	id, err := strconv.Atoi(r.URL.Query().Get("id"))
	if err != nil || id < 1 {
		http.NotFound(w, r)
		return
	}
	fmt.Fprintf(w, "Display a specific snippet with ID %d", id)
}
```

## The `io.Writer`interface

The code above introduced another new thing -- if U take a look at the document -- for the `fmt.Fprintf`, it takes an `io.Writer`as the first parameter.

# Understanding Migrations

Describe the migration feature, which is how EF core ensures the dbs reflects the data model in the applicatoin. Even as that model just changes. This is known as `code-first`.

Migrations are groups of commands that prepare dbs for use with EF core app. Without migrations, u would have to create the dbs using SQL commands and manually configure EF core core to use it.

## Working with the Initial Migration

- <timestamp>_Initial.cs -- parts of Initial class, which applies the first migration to the dbs.
- `<timestamp>_Initial.Designer.cs`-- this is part of Initial class, applies the first migration to the dbs. Contains instructions creating for model objects.
- `EFDatabaseContextModelSnapshot.cs`-- This class contains a desc of the entity classes used in this migration and used to detect changes for creating further migrations.

The part of the `Initial`class contains this methods that will make more sense shortly.

- `Up()`-- this contains statements that upgrade the dbs to store entity data.
- `Down()`-- downgrade the dbs to its original state.

When dealing with the migration that is applied to a newly created dbs, EF core creates a table for each `DbSet<T>`in the DbContext -- For this, there is noly one -- 

`migrationBuilder.CreateTable(name:"Proudcts")`

Provides methods that are used to specify the changes that will be applied to the dbs.

And the `Down`is used to return the dbs to its previous state, undoing the effect of the `Up`.

Applying the Migration -- A migration doesn't take effect until it is applied to the dbs. `Update-Database`specifies that you wnat to perform an operation on the dbs.

## Creating Additional Migrations

The convience of migrations becomes apparent when the data model in the MVC app changes.

```cs
public enum Colors
{
    Red, Green, Blue
}

public class Product
{
    public long Id { get; set; }

    public string? Name { get; set; }
    public string? Category { get; set; }
    public decimal Price { get; set; }

    public Colors Color {  get; set; }
}
```

For this, the `Color`prop uses the `Colors`enum -- Adding a prop means that `Product`objects can no longer be stored in the dbs since there is no means of storing `Color`values, note that.

Bringing the dbs into sync with the revised data model means that creating and applying a new migration. just:

```sh
add-migration AddColorProperty
```

The `Up`method will update the scheme to refect the change in the data model, which in this case means adding a column called `Color`to the `Products`table. Or:

```sh
dotnet ef migrations script Initial AddColorProperty
```

Show the statements required to update the dbs from the first migration to the second.

## Adding another to the Data model

FORE, add a new bool prop named `InStock`. Need to `add-migration`again like:... Creating a migraiton is only part of the process, a migration must also be applied to the dbs to ensure that the app data can be stored.

| Cmdlet               | Desc                            |
| -------------------- | ------------------------------- |
| `Add-Migration`      | Adds a new migration            |
| `Drop-Database`      | Drops the dbs                   |
| `Get_DbContext`      | Get info about a `DbContext`    |
| `Remove-Migration`   | Removes the last migration      |
| `Scaffold-DbContext` | Scofflds a `DbContext`for a dbs |
| `Get-Migration`      | Lists available migrations      |

For `Get-Migration`-- this command will list all of the migrations that have been created for a project.

## Applying All migrations

The most common task is to apply all of the migrations that are defined in the project to bring the dbs up-to-date.

`Update-Database`

## Adding, Sorting, Filtering, and Paging

Fore, storing in LINQ is done wy the methods `OrderBy`and `OrderByDescending`.

```cs
using (var context = new EfCoreContext(optionBulder.Options))
{
	var dto = context.Books.MapBookToDto();
	dto.OrderBooksBy2(OrderByOptions.ByVotes).Dump();
}

public static class some
{
	public static IQueryable<BookListDto> OrderBooksBy2
	(this IQueryable<BookListDto> books, OrderByOptions orderByOptions)
	{
		switch (orderByOptions)
		{
			case OrderByOptions.SimpleOrder:
				return books.OrderByDescending(x => x.BookId);
			case OrderByOptions.ByVotes:
				return books.OrderByDescending(x => x.ReviewsAverageVotes);
				// ...
			default:
				throw new ArgumentOutOfRangeException(nameof(orderByOptions), orderByOptions, null);
		}
	}
}
```

Calling the `OrderBookBy`method just returns the original query.

## Filtering books by Publication year, categories, and customer ratings

```cs
using (var context = new EfCoreContext(optionBulder.Options))
{
	context.Books
	.Where(x => x.PublishedOn <= DateTime.UtcNow.Date)
	.Select(x => x.PublishedOn.Year)
	.Distinct()  // returns a list of each year a book was published
	.Select(x => new ServiceLayer.BookServices.DropdownTuple
	{
		Value = x.ToString(),
		Text = x.ToString()
	}).Dump();
}
```

And the following is called `FilterBooksBy`-- takes an input `Value`part of the drop-down list, then by filtering some.

## Paging the books in the list

U can create a generic paging Query object that will work with any `IQueryable<T>`. like:

```cs
public static IQueryable<T> Page<T> (this IQueryable<T> query,
                                    	int pageNumZeroStart, int pageSize) {
    if(pageSize==0)
        throw ...;
    if (pageNumZeroStart!=0){
        query = query.skip(pageNumZeroStart*pageSize);
    }
    return query.Take(pageSize);
}
```

## Putting it all together

```cs
using (var context = new EfCoreContext(optionBulder.Options))
{
	var options = new SortFilterPageOptions();
	var query = context.Books.AsNoTracking()
	.MapBookToDto()
	.OrderBooksBy(options.OrderByOptions)
	.FilterBooksBy(options.FilterBy, options.FilterValue);
	query.Dump();
}
```

## Changing the Dbs Content

Moves on to changing the content of the dbs. Create, update, and delete.

### Introducing EF core's entity State

`Added`-- needs to be created in the dbs, `SaveChanges`inserts it.
`Unchanged`-- The entity just exists in the dbs and hasn't been modified on the client, ignores it
`Modified`-- `SaveChanges`updates it.
`Deleted`-- but should be deleted
`Detached`-- the entity provided isn't tracked. can't see it.

normally, don't look at or alter the `State`directly - use just various commands to add..

## Creating new row in a table

Start with an entity class that has no navigational properties -- relationship to other tables.. rare, but shows two steps in a create operation -- 

1. Add the entity to the app's `DbContext`
2. Call the app's `DbContext'`s `SaveChanges()`.

```cs
var itemToAdd= new Entity{
    ...
};
context.Add(itemToAdd); // add single entity to the app's DbContext, 
						// and the DbContext determines the table to add it to
						// based on its parameter's type
context.SaveChanges();
```

Cuz U add the entity that wan't **originally tracked** -- EF core starts to track it and sets its `State`to `Added`. 

And EF core just creates the SQL Command like

```sql
SET NOCOUNT on
INSERT into ...
Select id from entities where @@RowCount = 1 and
	id=scope_identity();
```

The second SQL just produced by EF core reads back the PK of the row that was created by the dbs server. This command ensures that the origianal `ExampleEntity`instance is updated with the pk so that the in-memory version of the entity is the same as the version in the dbs.

Reading back the PK is important, cuz might update the dbs, the update will need the PK.

## Creating a book with a review

```cs
using (var context = new EfCoreContext(optionBulder.Options))
{
	var book = new Book
	{
		Title = "Test Book",
		PublishedOn = DateTime.Today,
		Reviews = new List<DataLayer.EfClasses.Review>(){
			new DataLayer.EfClasses.Review{
				NumStars=5, Comment="Great test book", VoterName= "Mr Lee"
			}
		}
	};
	context.Add(book);
	context.SaveChanges();
}
```

The thing to note from this listing is **that** you add only the `Book`entity class, but, the related `Review`is also written to the dbs. This happens cuz -- **EF core will follow all the relationship links** and finds the new `Review`instance, and cuz the `Review`just isn't tracked, EF core knows that the `Review`needs to be added to the dbs.

If the linked instances are new (namely, not already known to EF core), EF core will start tracking them and set their `Steate`to `Added`. In all other cases, EF core will obey the `State`linked to the entity instance.

For this, the `Review`obj instance isn't already known to EF core, whieh means that its `State`is just `Detached`, but when the `Add` call is made, its state is set to `Added`.

## LifeCycle methods

The component works in the same way as a regular `NavLink`, but accepts an array of paths to match. And the component reles on the `OnParametersSet`lifecycle method cuz initial setup is required that cannot be performed until after values has been assigned to the props decorated with the `Parameter`attribute.

The lifecycle methods are also useful for performing tasks they may complete after the intiial content from the compnent has been rendered fore, querying the dbs. If use this:

```html
@if (Person == null)
{
    <h5 class="bg-info text-white text-center p-2">Loading...</h5>
}
```

The component can't query the dbs until the parameter values have been set and so that the value of the `Person`prop is obtained in the `OnParametersSetAsync()`

And, most components work together through parameters and events, allowing the user's interaction to drive changes in the application. References to components are created by adding `@ref`attr and specifying the name of a field or prop to which the component should be assigned. In other method, using this variable.

```cs
public void ToggleLinks(){
    foreach(... in Refs.Values) {..}
}
```

## Interacting with Components from other code

Components can be used by other code in core, allowing a richer interaction.

```cs
public void SetEnabled(bool enabled)
{
    InvokeAsync(() =>
    {
        Enabled = enabled;
        CheckMatch(NavManager!.Uri);
        StateHasChanged();
    });
}
```

Razor components provides two methods that are used in code that is invoked *outside of the Blazor environment*.

- `InvokeAsync(func)`-- used to execute a function inside the Blazor environment.
- `StateHasChanged()`-- called when a change occurs outside of the normal lifecycle.

So the `InvokeAsync`is used to invoke a function within the Blazor environment, Ensuring that changes are processed correctly -- The `StateHasChanged`is invoked when all the changes have been applied, triggering a Blaozr update and ensuring changes are just reflect **in the component's output**.

Fore, create a service that will be available throughout the app, 

```cs
public class ToggleService
{
    private List<MultiNavLink> components = new List<MultiNavLink>();
    private bool enabled = true;

    public void EnrolComponents(IEnumerable<MultiNavLink> comps)
    {
        components.AddRange(comps);
    }

    public bool ToogleComponents()
    {
        enabled= !enabled;
        components.ForEach(c=>c.SetEnabled(enabled));
        return enabled;
    }
}
```

This service manages a collection of components and invoke the `SetEnabled`method on all of them when its `ToggleComponents`is called. Just relies the C# classes that are produced when Razor Component (**RC**) are compiled. Then add it to the Program.cs file as a service.

`builder.Services.AddSingleton<Advanced.Services.ToggleService>();`

```cs
protected override void OnAfterRender(bool firstRender)
{
    if(firstRender && Toggler != null)
    {
        Toggler.EnrolComponents(Refs.Values);
    }
}

public void ToggleLinks()
{
    Toggler?.ToogleComponents();
}
```

Just note component references are not available until after the content has been rendered. So using the `OnAfterRender`to register the component referfences with the service.

Can use the service from a different part of the core app.

## Blazor Forms and Data

Describe the features that provdies for dealing with HTML forms -- including support for data validation. Note that Blazor provides a set of built-in components that present the user with a form that cna be easily validated. Forms remain one of the core building blocks of web apps.

The `EditForm`componetn is just used as a parent for individual form field components.

```cs
@page "/forms/edit/{id:long}"
@inject NavigationManager? NavManager
@inject DataContext? Context
@layout EmptyLayout

<h4 class="bg-primary text-white text-center p-2">Edit</h4>

<FormSpy PersonData="PersonData">
    <h4 class="text-center">Form Placeholder</h4>
    <div class="text-center">
        <NavLink class="btn btn-secondary mt-2" href="/forms">Back</NavLink>
    </div>
</FormSpy>

@code {

    [Parameter]
    public long Id { get; set; }

    public Person PersonData { get; set; } = new();

    protected async override Task OnParametersSetAsync()
    {
        if (Context != null)
        {
            PersonData = await Context.People.FindAsync(Id) ?? new Person();
        }
    }

}
```

# Accessing Application Data in a Directive

The simplest way to amke a directive more useful is to configure it using attributes applied to the host element, which allows each instance of the directive to be provided with its own configuration information and to adapt its behavior.

```html
<tr *ngFor="let item of getProducts(); let i = index">
	<td>{{i+1}}</td>
    <td>{{item.name}}</td>
    <td pa-attr pa-attr-class="bg-warning">{{item.category}}</td>
    <td pa-attr pa-attr-class="bg-info">{{item.price}}</td>
</tr>
```

Along with the new attr called `pa-attr-class`which has been used to specify the class to which the direceive sould add the host element like:

```ts
constructor(element: ElementRef, @Attribute("pa-attr-class") bgClass: string) {
    element.nativeElement.classList.add(bgClass || "table-success", "fw-bold")
}
```

Added a new constuctor which the `@Attribute`decorator has been applied. It specifies the name of the attr that should be used to provide a value for the ctor parameter when a new instance of the directive class is created.

## Using a single Host Element Attribute

The last example is just redundant, so:

```ts
constructor(element: ElementRef, @Attribute("pa-attr") bgClass: string) {
    element.nativeElement.classList.add(bgClass || "bg-success", "fw-bold");
}
```

Just specifies the `pa-attr`as the source of the `bgClass`parameter value.

And the main limitation of reading attributes with `@Attribute`is values are *static*, just:

```html
<tr ... [pa-attr]="getProducts().length<6?'bg-success':'bg-warnning'">
	<td [pa-attr]="item.category=='Soccer'?'bg-info':null">
    	{{item.category}}
    </td>
</tr>
```

```ts
@Input("pa-attr")
bgClass: string | null = "";

ngOnInit() {
    this.element.nativeelement.classList.add(this.bgClass || "bt-success", "fw-bold");
}
```

Definedy by applying the `@Input`decorator to a property and using it to specify the name of the attribute that contains the expression.

For this example, the role of the ctor has changed in this – when Ng creates a new instance of a directive class, the ctor is invoked to create a new directive object, and only then is the vlaue of the input property set. This means that the ctor cannot access the input prop value cuz its value will not be set by Ng **until after the ctor has completed** and the new directive object has been produced.

## Responding to Input Property Changes

To handle changes, a directive must implement the `ngOnChanges`method to receive notifications when the value of an input prop changes like:

```ts
ngOnChanges(changes: SimpleChanges) {
    let change: SimpleChange = changes["bgClass"]
    let classList:DOMTokenList = this.element.nativeElement.classList;
    if (!change.isFirstChange() && classList.contains(change.previousValue)) {
        classList.remove(change.previousValue);
    }
    if (!classList.contains(change.currentValue)){
        classList.add(change.currentValue);
    }
}
```

Note that the `ngOnChanges`called once before the `ngOnInit`and then called.. each time there are changes to any of a directive’s input props. For the `SimpleChanges`which is a map keys refer to each changed input property, and whose values are `SimpleChange`object.

- `previousValue`– previous value of the input prop
- `isFirstChange()`– return `true`if this is the call to the `ngOnChanges`occurs before `ngOnInit`

## Creating Custom Events

*Output properties* are the Ng features that allows directive to add custom events to their host elements.

```ts
@Directive({
    selector: "[pa-attr]"
})export class PaAttrDirective {
    constructor(private element: ElementRef) {
        this.element.nativeElement.addEventListener('click', ()=> {
            if(this.product != null)  {
                this.click.emit(this.product.category);
            }
        });
    }
    
    //...
    
    @Input("pa-product")
    product: Product = new Product();
    
    @Output("pa-category")
    click = new EventEmitter<string>();
}
```

- `emit(value)`– this triggers the custom event associated with the `EventEmitter`, providing the listeners with the object or value received as the meothod argument.

```html
<tr ... [pa-product]="item" (pa-category)="newProdcut.category=$event">...</tr>
```

`$event`is used to access the value the directive passed to the `EventEmitter<string>.emit`. Namely,`emit()`'s parameter is just the newProduct.category’s result. cuz `[pa-product]`is set to item (which is the current tr binding `Product`obj), so, its name is just the click.emit(this.product.category), the current row’s category string.

## Creating Host Element Bindings

Even if you are sure that a directive will have access to the DOM, the same results can be achieved in a more elegant way using std Ng directive features. Rather than use the DOM to add and remove classes, a class binding can be used on the host element.

Behind he scenes, Ng mechanism when the directie is used in a different environment. – using : `@HostBinding`and `@HostListener`. Just:

```ts
@Input("pa-attr")
@HostBinding("class")
bgClass: string | null = "";

@Input("pa-product")
product: Product = new Product();

@Output("pa-category")
click = new EventEmitter<string>();

@HostListener("click")
triggerCustomEvent() {
    if (this.product != null)
        this.click.emit(this.product.category);
}
```

The `@HostBinding`decorator is used to set up a prop binding on the host element and is applied to a directive prop. This means that sets up a binding between the `class`prop on the host element and the `bgClass`.

And the `@HostListener`is used to set up an event binding on the host element and is applied to a method. The listing creates an event binding for the `click`, and will call the `triggerCustomEvent()`uses the `emit`to dispatch the custom event through the output property. The HTML source is not changed.

And note that the ctor is removed since there is no need to access the HTML element’s class.

## Creating a Two-way binding on the Host element

Directives can support two-way bindings.

```ts
@Directive({
	selector: "input[paModel]"
})
export class PaModel implements OnChanges {
	@Input("paModel")
	modelProperty?: string;

	@HostBinding("value")
	fieldValue: string = "";

	ngOnChanges(changes: SimpleChanges): void {
		let change: SimpleChange = changes["modelProperty"];
		if (change.currentValue != this.fieldValue) {
			this.fieldValue = changes["modelProperty"].currentValue || "";
		}
	}

	@Output("paModelChange")
	update = new EventEmitter<string>();

	@HostListener("input", ["$event.target.value"])
	updateValue(newValue: string) {
		this.fieldValue = newValue;
		this.update.emit(newValue);
	}
}
```

Note that the `selector`here match `input`element that have a `paModel`attribute. The built-in `ngModel`two-way directive has support for a range of form elements, and knoww which events and properties each of them uses.

This binding is implemented using an input prop and the `ngOnChanges`method, which responds to changes in the expression value by updating the contents of the input element through a host binding on the `input`'s `value`prop.

Notice that the method invoked by the event can receive the event object by specifying an additional arg:

`@HostListener("input", ["$event.target.value"])`

First decoreator specifies the name of the event that will be handled by the listener of course – second is an array that will be used to provide the decorated methods with args. In this, the `input`will be handled by listener, and when the `updateValue()`is called, its `newValue`will be set to target.value prop of `Event`.

```html
<div class="mb-3 bg-info text-white p-2">
    <label>Name:</label>
    <input class="bg-primary text-white form-control"
           [paModel]="newProduct.name"
           (paModelChange)="newProduct.name=$event" />
</div>
```

Can just be:

```html
<input class="bg-primary text-white form-control"
				   [(paModel)]="newProduct.name"/>
```

When encounters the `[()]`, it just expands the binding to match the format used, targeting the `paModel`and setting up the `paModelChange`event.

## Exporting a Directive for use in a Template Variable

fore: `<form #form="ngForm" (ngSubmit)="submitForm(form)">` –The `form`var is assigned to `ngForm`, which is then used to access validation info for the form. Can custom like:

```ts
@Directive({
	selector: "input[paModel]",
	exportAs: "paModel"
})export class ...
```

```html
<input ... #paModel="paModel" />
```

# Modular CSS

*Modular CSS* means breaking the page up into its component parts. These parts should be reusable in multiple contexts.

Akin to use of modular furniture. CSS doesn’t have the concepts of data or traditional functions but it does have selectors and the elements those selectors target.

```css
.message {
    padding: 0.8em 1.2em;
    border-radius: 0.2em;
    border: 1px solid #265559;
    color: #265559;
    background-color: #e0f0f2;
}

.message--success{
    color: #245926;
    border-color: #2f5926;
    background-color: #cfe8c9;
}

.message--warning {...}
```

So the modifer styles don’t need to redefine the entire module. Only need to override the parts they changes. just like:

```html
<div class="message message--error">...</div>
```

## Modules with multiple elements

```css
.media {
    padding: 1.5em;
    background-color: #eee;
    border-radius: 0.5em;
}

.media::after {
    content: "";
    display: block;
    clear:both;
}

.media__image{
    float:left;
    margin-right: 1.5em;
}

.media__body {
    overflow: auto;  /*bfc*/
    margin-top: 0;
}

.media__right > .media__image {
    float: right;
}
```

Make it just `<div class="media media--right">`

## Modules composed into large structures

Your modules should each be responsbile for one thing – Message module is responsible for making a message noticeable. should be able to concisely summarize its purpose. At a high level, what is the module’s responsbility.

## Deviding multiple responsibilities among modules

Build the dropdown menu with two different modules.

```css
.dropdown {
    display: inline-block;
    position: relative;
}

.dropdown__toggle {
    padding: 0.5em 2em 0.5em 1.5em;
    border: 1px solid #ccc;
    font-size: 1rem;
    background-color: #eee;
}

.dropdown__toggle::after {
    content: "";
    position: absolute;
    right: 1em;
    top: 1em;
    border: 0.3em solid;
    border-color: black transparent transparent;
}

.dropdown__drawer {
    display: none;
    position: absolute;
    left: 0;
    top: 2.1em;
    min-width: 100%;
    background-color: #eee;
}

.dropdown.is-open .dropdown__toggle::after {
    top: 0.7em;
    border-color: transparent transparent black;
}

.dropdown.is_open .dropdown__drawer {
    display: block;
}
```

### State Classes

The `is-open`class has a special purpose in the module. Intended to be added or removed from the module dynamically using js. It’s just common convention to design all state classes begin with `is-`or `has-`this way.

## Preprocessors and Modular CSS

A feature that all preprocessors like `SASS`or `LESS`provide is the ability to merge separate CSS file into one. This just lets you organize styles into multiple files and directories, but serve them all to the browser as one file. It just reduces the number of network requests necessary from the browser.

Organize these into directories as needed – **in its own appropriately named file**.

For now, with the `Dropdown`working, focus on the Menu module.

```css
.menu {
    margin: 0;
    padding-left: 0;
    list-style-type: none;
    border: 1px solid #999;
}

.menu>li+li {
    border-top: 1px solid #999;
}

.menu>li>a {
    display: block;
    padding: 0.5em 1.5em;
    background-color: #eee;
    color: #369;
    text-decoration: none;
}

.menu>li>a:hover {
    background-color: #fff;
}
```

## Utility Classes

Sometimes you will need a class to do one simple, very specific thing to an element. This could mean centering text, floating it left… or Adding a clearfix, keep these classes all near the end of stylesheet. fore:

```css
.text-center {
    text-align: center !important;
}

.float-left {
    float: left;
}

.clearfix::before,
.clearfix::after
{
    content: " ";
    display: table;
}

.clearfix::after{
    clear:both;
}
.hidden {
    display:none !important;
}
```

Note that these classes are the only place should use the important annotation.
